{-
# アルゴリズミックにパターンを生成する
-}

{-
## ユークリッド・シーケンス: `(,,)`
2つの自然数の最大公約数を求める「ユークリッドの互除法」を応用したアルゴリズム
-}
d1 $ sound "bd(3, 8)"
-- -> 1サイクルを8分割したパターンの中に3回音を再生する

-- 1. [1 1 1 0 0 0 0 0]
-- 2. [1 0] [1 0] [1 0] [0 0] <- 1と0が対になるように右側の0を移動させる
-- 3. [1 0 0] [1 0 0] [1 0]   <- 右側に0もしくは1が余っている場合は左から順番に移動させる
-- 4. |bd     |bd     |bd  |

d1 $ sound "cp(5, 8)"
-- -> 1サイクルを8分割したパターンの中に5回音を再生する

-- 1. [1 1 1 1 1 0 0 0]
-- 2. [1 0] [1 0] [1 0] [1 1] <- 1と0が対になるように右側の0を移動させる
-- 3. [1 0 1] [1 0 1] [1 0]   <- 右側に0もしくは1が余っている場合は左から順番に移動させる
-- 4. |cp ~ cp |cp ~ cp |cp  |

-- ユークリッド・シーケンスに3つ目の引数を指定するとその数値だけパターンを右方向にシフトする
-- (3, 8)    = [1 0 0 1 0 0 1 0]
-- (3, 8, 0) = [1 0 0 1 0 0 1 0]
-- (3, 8, 1) = [0 1 0 0 1 0 0 1]
-- (3, 8, 2) = [1 0 1 0 0 1 0 0]

d1 $ sound "[bd(3, 8), cp(3, 8, 3), tabla2(5, 8, 4)]"

{-
## 乱数: `rand`, `irand`, `choose`
-}
d1
  $ sound "[bd(3, 8), cp(3, 8, 3), tabla2(5, 8, 4)]"
  # n (irand 12) -- int 0~11
  # pan (rand)   -- 0.0 ~ 1.0

-- randで生成したランダムの範囲を変化させるには `sclae`関数を組み合わせる
-- エラー? -> d1 $ sound "arpy*4" # pan (scale 0.25 0.75 $ rand)

-- `choose`: 指定した数値の中から１つだけをランダムに選択すること
d1 $ s "[bd(3, 8), cp(3, 8, 4), tabla2(2, 5, 4)]"
  # n (irand 12)
  # up (choose [0, 4, 5, 7]) -- 0~11 で 0,4,5,7 のどれかを選

d2
  $ jux ((choose[0.125, 0.25, 0.5]) <~)
  $ sound "[bd(3, 8), cp(3, 8, 3), tabla2(5, 8, 4)]"
  # pan (rand)
  # n (irand 12)
  # up (choose [0, 4, 5, 7])
  # delay "0.5"
  # delaytime (choose [0.0652, 0.125, 0.25, 0.5])

{-
## パターンを変数として格納
-}
d1
  $ gain "[1 0 1 0 1 1 0 0]"
  # sound "bd"

let pat1 = "[1 0 1 0 1 1 0 0]"

d2 $ gain pat1 # s "bd"

do
  let
    pat2 = "[1 0 1 0 1 1 0 0]"
  d1
    $ gain pat2 # s "bd"

do
  let
    p1 = "{1 0 1 0 1/2 1 0 0 1}%8"
    p2 = "{1 0 0 1 0 1 0 1/2 1 0 0 1/3}%8"
  d1
    $ gain p1 # s "bd"
  d2
    $ gain p2 # s "cp"

  
